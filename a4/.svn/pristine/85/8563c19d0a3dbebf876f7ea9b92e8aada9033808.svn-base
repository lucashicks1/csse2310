#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <unistd.h>
#include <netdb.h>
#include <csse2310a4.h>
#include <csse2310a3.h>

#define MAX_ARGS 2
#define MIN_ARGS 1


#define USAGE_MESSAGE "Usage: crackclient portnum [jobfile]\n"
#define JOB_FILE_MESSAGE "crackclient: unable to open job file \"%s\"\n"
#define CONNECTION_ERROR_MESSAGE "crackclient: unable to connect to port %s\n"
#define TERMINATE_MESSAGE "crackclient: server connection terminated\n"

#define SERVER_INVALID ":invalid\n"
#define INVALID_MESSAGE "Error in command\n"
#define SERVER_FAILED ":failed\n"
#define FAILED_MESSAGE "Unable to decrypt\n"

typedef enum {
    USAGE_ERROR = 1,
    JOB_FILE_ERROR = 2,
    CONNECTION_ERROR = 3,
    CONNECTION_TERMINATED = 4,
    OK = 0
} ExitStatus;

typedef struct {
    const char* portNum;
    char* jobFile;
} ClientDetails;

//TODO Add error functions

ClientDetails parse_command_line(int argc, char** argv);
int setup_connection(const char* port);
void communicate_with_server(int connFD, char* jobFile);
void send_command(char* line, FILE* out);
void handle_response(char* response);

int main(int argc, char** argv) {
    ClientDetails clientDetails;
    int connFD;
    

    clientDetails = parse_command_line(argc, argv);
    connFD = setup_connection(clientDetails.portNum);

    if (connFD < 0) {
        fprintf(stderr, CONNECTION_ERROR_MESSAGE, clientDetails.portNum);
        exit(CONNECTION_ERROR);
    }

    communicate_with_server(connFD, clientDetails.jobFile);

    return OK;
}

void communicate_with_server(int connFD, char* jobFile) {
    FILE* inputSource;
    char* line;
    char buffer[80];
    bool terminated = false;

    //Setting up to and from connectors from client<->server
    int fd2 = dup(connFD);
    FILE* out = fdopen(connFD, "w");
    FILE* in = fdopen(fd2, "r");

    if (jobFile) {
        inputSource = fopen(jobFile, "r");
    } else {
        inputSource = stdin;
    }

    //Read from stdin or jobFile
    while ((line = read_line(inputSource))) {
        // Check for blank lines and comments
        if (line[0] == '#' || line[0] == '\0' || line[0] == ' ') {
            free(line);
            continue;
        }
        // Send line to server
        send_command(line, out);

        // Check if connection was terminated
        if (!fgets(buffer, sizeof(buffer) - 1, in)) {
            terminated = true;
            break;
        }

        // Interpret server reponse
        handle_response(buffer);
    }
    fclose(inputSource);
    fclose(in);
    fclose(out);
    close(fd2);
    close(connFD);

    if (terminated) {
        fprintf(stderr, TERMINATE_MESSAGE);
        exit(CONNECTION_TERMINATED);
    } 

}

void send_command(char* line, FILE* out) {
    fprintf(out, "%s\n", line);
    fflush(out);
    free(line);
}

void handle_response(char* response) {
    if (!strcmp(response, SERVER_INVALID)) {
        printf("%s", INVALID_MESSAGE);
    } else if (!strcmp(response, SERVER_FAILED)) {
        printf("%s", FAILED_MESSAGE);
    } else {
        printf("%s", response);
    }
    fflush(stdout);
}

int setup_connection(const char* port) {
    struct addrinfo* ai = 0;
    struct addrinfo hints;
    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;
    int err;
    if ((err = getaddrinfo("localhost", port, &hints, &ai))) {
        freeaddrinfo(ai);
        return -1;
    }

    int fd = socket(AF_INET, SOCK_STREAM, 0);
    if (connect(fd, ai->ai_addr, sizeof(struct sockaddr))) {
        return -1;
    }
    freeaddrinfo(ai);
    return fd;

}

ClientDetails parse_command_line(int argc, char** argv) {
    ClientDetails clientDetails = {.portNum = NULL, .jobFile = NULL};

    // Skip program name
    argc--;
    argv++;

    if (argc > MAX_ARGS || argc < MIN_ARGS) {
        fprintf(stderr, USAGE_MESSAGE);
        exit(USAGE_ERROR);
    }

    clientDetails.portNum = argv[0];

    if (argc == 2) {
        clientDetails.jobFile = argv[1];
        FILE* jobFile = fopen(argv[1], "r");
        if (!jobFile) {
            fprintf(stderr, JOB_FILE_MESSAGE, clientDetails.jobFile);
            exit(JOB_FILE_ERROR);
        }
    }

    return clientDetails;
}
