#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <csse2310a4.h>
#include <csse2310a3.h>
#include <stdbool.h>
#include <pthread.h>
#include <crypt.h>
#include <ctype.h>

#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define MAX_ARGS 6
#define MAX_WORD_LENGTH 8
#define MIN_PORT 1024
#define MAX_PORT 65535
#define MAX_FIELDS 3
#define CIPHER_LENGTH 13
#define SALT_LENGTH 2

#define MIN_THREADS 1
#define MAX_THREADS 50

#define ASCII_MIN 46
#define ASCII_MAX 57

#define FAILED ":failed"
#define INVALID ":invalid"

#define DEFAULT_DICTIONARY "/usr/share/dict/words"

// Semaphores for statistics

typedef enum {
    USAGE_ERROR = 1,
    DICT_FILE_ERROR = 2,
    NO_WORDS_ERROR = 3,
    UNABLE_OPEN_ERROR = 4,
} ExitStatus;

typedef struct {
    int maxConns;
    const char* portNum;
    char* dictFileName;
} ServerDetails;

typedef struct {
    char** words;
    int numWords;
} Dictionary;

typedef struct {
    int fd;
    Dictionary* dict;
} ClientThreadData;

ServerDetails parse_command_line(int argc, char** argv);
void validate_port_number(int portNum);
int validate_max_connections(int maxConns);
Dictionary fill_dictionary(char* dictFileName);

void process_connections(int serv, Dictionary dict);
int open_listen(const char* port);

void process_command(char* command, FILE* out);

void* client_wrapper(void* v);
void client_handler_thread(int fd, Dictionary* dict);
char* crypt_call(char* cryptText, char* salt);

//Helper prototypes
void free_dictionary(Dictionary);
int string_to_number(char* arg);
bool valid_thread_num(char* numThreads);
bool valid_salt(char* salt);
bool valid_salt_character(char salt);

// Prototypes for error functions
void usage_error();
void dictionary_error(char* dictName);
void empty_dictionary_error();
void unable_listen_error();

int main(int argc, char** argv) {
    ServerDetails serverDetails;
    Dictionary dictionary;
    int serv;

    serverDetails = parse_command_line(argc, argv);
    dictionary = fill_dictionary(serverDetails.dictFileName);

    if ((serv = open_listen(serverDetails.portNum)) < 0) {
        free_dictionary(dictionary);
        unable_listen_error();
    }

    process_connections(serv, dictionary);

    return 0;
}

ServerDetails parse_command_line(int argc, char** argv) {
    ServerDetails param = {.maxConns = -1, .portNum = NULL, 
        .dictFileName = NULL};

    // Skip program name
    argc--;
    argv++;

    if (argc > MAX_ARGS || argc % 2) {
        usage_error();
    }

    while (argc) {
        if (strcmp(argv[0], "--maxconn") == 0 && param.maxConns < 0) {
            int maxConns = string_to_number(argv[1]);
            param.maxConns = validate_max_connections(maxConns);
        } else if (strcmp(argv[0], "--port") == 0 && !param.portNum) {
            int portNum = string_to_number(argv[1]);
            validate_port_number(portNum);
            param.portNum = argv[1];
        } else if (strcmp(argv[0], "--dictionary") == 0 
                && !param.dictFileName) {
            param.dictFileName = argv[1];
        } else {
            usage_error(); // If additional or duplicates args are provided
        }

        argc -= 2;
        argv += 2;
    }

    // Sets portnum to be 0 if not specified
    if (!param.portNum) {
        param.portNum = "0";
    }
    // Uses default dictionary if not specified
    if (!param.dictFileName) {
        param.dictFileName = DEFAULT_DICTIONARY;
    }

    return param;

}

// Listens on given port, returns socket for listening
int open_listen(const char* port) {
    struct addrinfo* ai = 0;
    struct addrinfo hints;

    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_family = AF_INET;   // IPv4
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;    // listen on all IP addresses

    int err;
    if((err = getaddrinfo(NULL, port, &hints, &ai))) {
        freeaddrinfo(ai);
        return 1;   // Could not determine address
    }

    // Create a socket and bind it to a port
    int listenfd = socket(AF_INET, SOCK_STREAM, 0); // 0=default protocol (TCP)

    // Allow address (port number) to be reused immediately
    int v = 1;
    if(setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, 
                &v, sizeof(v)) < 0) {
        return -1;
    }

    if(bind(listenfd, ai->ai_addr, sizeof(struct sockaddr)) < 0) {
        return -1;
    }

    if (listen(listenfd, 10)  < 0) {
        return -1;
    }

    // Find out which socket
    struct sockaddr_in ad;
    memset(&ad, 0, sizeof(struct sockaddr_in));
    socklen_t len = sizeof(struct sockaddr_in);
    if (getsockname(listenfd, (struct sockaddr*)&ad, &len)) {
        perror("sockname");
        return -1;
    }
    printf("%u\n", ntohs(ad.sin_port));

    // Have listening socket - return it
    return listenfd;
}


void process_connections(int serv, Dictionary dict) {
    int fd;
    struct sockaddr_in fromAddr;
    socklen_t fromAddrSize;

    //TODO Make the struct to hold sighup info
    //TODO Create sighup thread - this thread will just sigwait

    // Repeatedly accept connections
    while(1) {
        fromAddrSize = sizeof(struct sockaddr_in);
        // blocking call
        fd = accept(serv, (struct sockaddr*)&fromAddr,  &fromAddrSize);

        if(fd < 0) {
            perror("Error accepting connection");
            exit(1);
        }
     

        ClientThreadData* data = malloc(sizeof(ClientThreadData));
        data->fd = fd;
        data->dict = &dict;

        pthread_t threadID;
        pthread_create(&threadID, 0, client_wrapper, data);
        pthread_detach(threadID);
    }
}

void* client_wrapper(void* v) {
    ClientThreadData* data  = (ClientThreadData*)v;
    client_handler_thread(data->fd, data->dict);
    
    return NULL;
}

void client_handler_thread(int fd, Dictionary* dict) {
    char* line;

    int fd2 = dup(fd);
    FILE* in = fdopen(fd, "r");
    FILE* out = fdopen(fd2, "w");

    while ((line = read_line(in))) {
        printf("%s\n", line);
        process_command(line, out);
    }

}

void process_command(char* command, FILE* out) {
    char** parts = split_by_char(command, ' ', MAX_FIELDS);
    char* result;

    if (parts[0] == NULL || parts[1] == NULL || parts[2] == NULL) {
        result = INVALID;
    } else if (strcmp(parts[0], "crack") == 0) {
        // Check if ciphertext length valid, number of threads valid
        if (strlen(parts[1]) != CIPHER_LENGTH || !valid_thread_num(parts[2])) {
            result = INVALID;
        // Checks if salt in substring is valid
        } else if (!valid_salt_character(parts[1][0])
                || valid_salt_character(parts[1][1])) {
            result = INVALID;
        } else {
            result = "Crack Command";

        }
    } else if (strcmp(parts[0], "crypt") == 0) {
        // Checking salt
        if (!valid_salt(parts[2])) {
            result = INVALID;
        } else {
            result = crypt_call(parts[1], parts[2]);
        }
    } else {
        result = INVALID;
    }

    fprintf(out, "%s\n", result);
    fflush(out);
}

char* crypt_call(char* cryptText, char* salt) {
    char* hash;
    // Create crypt struct in order to use crypt_r (reentrant version)
    struct crypt_data data;
    // Zero the entire data struct
    memset(&data, 0, sizeof(struct crypt_data));
    hash = crypt_r(cryptText, salt, &data);
    return hash;
}

bool valid_salt(char* salt) {
    // Check the length of the salt
    if (strlen(salt) != SALT_LENGTH) {
        return false;
    }

    // Check that each char in the salt is valid
    for (int i = 0; i < SALT_LENGTH; i++) {
        if (!valid_salt_character(salt[i])) {
            return false;
        }
    }
    return true;
}

// Checking if the salt is a valid character
// ASCII values are used to check if number or . or /
bool valid_salt_character(char salt) {
    int saltNum = salt;
    return isalpha(salt) || ((saltNum > ASCII_MIN) & (saltNum < ASCII_MAX));
}

bool valid_thread_num(char* numThreads) {
    // Not using string_to_number as 0 is a false thread num
    int num = atoi(numThreads);
    if (num < MIN_THREADS || num > MAX_THREADS) {
        return false;
    }
    return true;
}

Dictionary fill_dictionary(char* dictName) {
    Dictionary param = {.words = NULL, .numWords = 0};
    param.words = malloc(0);
    char* line;
    
    FILE* dictFileStream = fopen(dictName, "r");

    if (!dictFileStream) {
        free(param.words);
        dictionary_error(dictName);
    }
    // TODO Why do i have to consider if words are no longer than 50 chars
    while ((line = read_line(dictFileStream))) {
        if (strlen(line) > MAX_WORD_LENGTH) {
            free(line);
            continue;
        }
        param.numWords++;
        param.words = realloc(param.words, param.numWords * sizeof(char*));
        param.words[param.numWords - 1] = line;
    }
    if (!param.numWords) {
        free(param.words);
        empty_dictionary_error();
    }


    return param;
} 

void free_dictionary(Dictionary dict) {
    for (int i = 0; i < dict.numWords; i++) {
        free(dict.words[i]);
    }
    free(dict.words);
}

int string_to_number(char* arg) {
    char* end;
    int num;
    num = strtol(arg, &end, 10);

    // Checking if entire string was read and converted
    if (*end != '\0') {
        usage_error();
    } 
    return num;
}

void validate_port_number(int portNum) {
    if (portNum != 0 && (portNum < MIN_PORT || portNum > MAX_PORT)) {
        usage_error();
    }
}

int validate_max_connections(int maxConns) {
    // Checking if negative number given
    if (maxConns < 0) {
        usage_error();
    }
    return maxConns;
}

void usage_error() {
    fprintf(stderr, "Usage: crackserver [--maxconn connections] [--port "\
            "portnum] [--dictionary filename]\n");
    exit(USAGE_ERROR);
}

void dictionary_error(char* dictName) {
    fprintf(stderr, "crackserver: unable to open dictionary file \"%s\"\n", 
            dictName);
    exit(DICT_FILE_ERROR);
}

void empty_dictionary_error() {
    fprintf(stderr, "crackserver: no plain text words to test\n");
    exit(NO_WORDS_ERROR);
}

void unable_listen_error() {
    fprintf(stderr, "crackserver: unable to open socket for listening\n");
    exit(UNABLE_OPEN_ERROR);
}
