#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <csse2310a4.h>
#include <csse2310a3.h>

#define MAX_ARGS 6
#define MAX_WORD_LENGTH 8
#define MIN_PORT 1024
#define MAX_PORT 65535

#define DEFAULT_DICTIONARY "/usr/share/dict/words"

typedef enum {
    USAGE_ERROR = 1,
    DICT_FILE_ERROR = 2,
    NO_WORDS_ERROR = 3,
    UNABLE_OPEN_ERROR = 4,
    UNABLE_LISTEN_ERROR = 5
} ExitStatus;

typedef struct {
    int maxConns;
    char* portNum;
    char** dictionary;
} ServerDetails;

ServerDetails parse_command_line(int argc, char** argv);
int string_to_number(char* arg);
void validate_port_number(int portNum);
int validate_max_connections(int maxConns);
char** populate_dictionary(char* dictName);
void usage_error();
void dictionary_error(char* dictName);
void empty_dictionary_error();

int main(int argc, char** argv) {
    ServerDetails serverDetails;

    serverDetails = parse_command_line(argc, argv);

    printf("PROGRAM\n");

    return 0;
}

ServerDetails parse_command_line(int argc, char** argv) {
    ServerDetails param = {.maxConns = -1, .portNum = NULL, 
        .dictionary = NULL};
    char* dictionaryFileName = NULL;

    // Skip program name
    argc--;
    argv++;

    if (argc > MAX_ARGS || argc % 2) {
        usage_error();
    }

    while (argc) {
        if (strcmp(argv[0], "--maxconn") == 0 && param.maxConns < 0) {
            int maxConns = string_to_number(argv[1]);
            param.maxConns = validate_max_connections(maxConns);
        } else if (strcmp(argv[0], "--port") == 0 && !param.portNum) {
            int portNum = string_to_number(argv[1]);
            validate_port_number(portNum);
            param.portNum = argv[1];
        } else if (strcmp(argv[0], "--dictionary") == 0 
                && !dictionaryFileName) {
            dictionaryFileName = argv[1];
        } else {
            usage_error();
        }

        argc -= 2;
        argv += 2;
    }

    if (!dictionaryFileName) {
        dictionaryFileName = DEFAULT_DICTIONARY;
    }

    param.dictionary = populate_dictionary(dictionaryFileName);

    return param;

}

char** populate_dictionary(char* dictName) {
    char** dictionary = malloc(0);
    char* line;
    int numWords = 0;
    
    FILE* dictFileStream = fopen(dictName, "r");

    if (!dictFileStream) {
        free(dictionary);
        dictionary_error(dictName);
    }


    while ((line = read_line(dictFileStream))) {
        if (strlen(line) > MAX_WORD_LENGTH) {
            free(line);
            continue;
        }
        numWords++;
        dictionary = realloc(dictionary, numWords * sizeof(char*));
        dictionary[numWords-1] = line;

        printf("%p\n", dictionary[numWords-1]);
    }

    if (!numWords) {
        free(dictionary);
        empty_dictionary_error();
    }

    return dictionary;

} 


int string_to_number(char* arg) {
    char* end;
    int num;
    num = strtol(arg, &end, 10);

    // Checking if entire string was read and converted
    if (*end != '\0') {
        usage_error();
    } 
    return num;
}

void validate_port_number(int portNum) {
    if (portNum != 0 && (portNum < MIN_PORT || portNum > MAX_PORT)) {
        usage_error();
    }
}

int validate_max_connections(int maxConns) {
    // Checking if negative number given
    if (maxConns < 0) {
        usage_error();
    }
    return maxConns;
}

void usage_error() {
    fprintf(stderr, "Usage: crackserver [--maxconn connections] [--port"\
            "portnum] [--dictionary filename]\n");
    exit(USAGE_ERROR);
}

void dictionary_error(char* dictName) {
    fprintf(stderr, "crackserver: unable to open dictionary file \"%s\"", dictName);
    exit(DICT_FILE_ERROR);
}

void empty_dictionary_error() {
    fprintf(stderr, "crackserver: no plain text words to test\n");
    exit(NO_WORDS_ERROR);
}
