#include <csse2310a3.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

// Enum to hold exit statuses
typedef enum {
    OK = 0,
    USAGE_ERROR = 2,
    JOB_FILE_ERROR = 3,
    JOB_FORMAT_ERROR = 4,
    INPUT_FILE_ERROR = 5,
    BLANK_JOB_ERROR = 6
} ExitStatus;

// Structure to hold program information including optional arguments and the
// names of the test program file and job file
typedef struct {
    bool quiet;
    bool parallel;
    char* testProgramName;
    char* jobFileName;
} ProgramParameters;

typedef struct {
    int totalNumJobs;
    char*** jobs;
} JobDetails;

// Function prototypes
ProgramParameters parse_args(int argc, char** argv);
JobDetails parse_job_file(char* jobFileName);
int count_character(char* word, char letter);
void usage_error();
void job_format_error(int lineNum, char* fileName);


int main(int argc, char** argv) {
    ProgramParameters programDetails;
    JobDetails jobDetails;


    programDetails = parse_args(argc, argv);
    jobDetails = parse_job_file(programDetails.jobFileName);


    if (programDetails.quiet || jobDetails.jobs) {
        printf("Quiet Mode Used\n");
    }

    return 0;
}

ProgramParameters parse_args(int argc, char** argv) {
    ProgramParameters info = { .quiet= false, .parallel = false,
            .testProgramName = NULL, .jobFileName = NULL};
    // Skip over program name argument
    argc--;
    argv++;
    // Check amount of arguments
    if (argc < 2 || argc > 4) {
        usage_error();
    }
    // Check for optional arguments if they exist
    while (argc > 2) {
        if (strcmp(argv[0], "--quiet") == 0 && !info.quiet) {
            info.quiet= true;
        } else if (strcmp(argv[0], "--parallel") == 0 && !info.parallel) {
            info.parallel = true;
        } else {
            usage_error();
        }
        argc--;
        argv++;
    }
    if ((argv[0][0] == '-' && argv[0][1] == '-') || 
        (argv[1][0] == '-' && argv[1][1] == '-')) {
        usage_error();
    }
    info.testProgramName = argv[0];
    info.jobFileName = argv[1];

    return info;
}

JobDetails parse_job_file(char* jobFileName) {

    char*** jobs = malloc(0);
    int totalNumJobs = 0;
    char* line;
    int lineNum = 0;
    int numArgs;
    FILE* file = fopen(jobFileName, "r");

    if (!file) {
        fprintf(stderr, "testuqwordiply: Unable to open job file \"%s\"\n", 
             jobFileName);
        exit(JOB_FILE_ERROR);
    }

    while ((line = read_line(file))) {
        lineNum++;
        // Checks for comments and blank lines
        if (line[0] == '#' || line[0] == '\0') {
            continue;
        }

        // Check for char before comma, and number of commas

        char** jobItems = split_line(line, ',');
        // TODO CHECK IF AT LEAST ONE CHARACTER BEFORE COMMA
        

        // TODO CHECK IF CONTAINS AT LEAST 1 COMMA TO ENSURE VALID
        

        // TODO CHECK IF INPUT FILE CAN BE OPENED

        char** args = split_space_not_quote(jobItems[1], &numArgs);

        char** job = malloc((numArgs+2) * sizeof(char*));

        job[0] = strdup(jobItems[0]);
        memcpy(job + 1, args, (numArgs + 1) * sizeof(char*));

        //free(line);
        int i = 0;
        while (job[i] != NULL) {
            printf("Arg: %s\n", job[i]);
            i++;
        }

        jobs = realloc(jobs, (totalNumJobs + 1) * sizeof(char**));

        jobs[totalNumJobs] = job;
        totalNumJobs++;
    }

    fclose(file);


    printf("%d", totalNumJobs);
    JobDetails jobDetails = {.totalNumJobs = totalNumJobs, .jobs = jobs};
    return jobDetails;
}

int count_character(char* word, char letter) {
    int numOccurrences = 0;
    for (int i = 0; word[i] != '\0'; i++) {
        if (word[i] == letter) {
            numOccurrences++;
        }
    }
    return numOccurrences;
}

void usage_error() {
    printf("Usage: testwordiply [--quiet] [--parallel] testprogram "
            "jobfile\n");
    exit(USAGE_ERROR);
}

void job_format_error(int lineNum, char* fileName) {
    fprintf(stderr, "testuqwordiply: syntax error on line %d of \"%s\"", 
        lineNum, fileName);
    exit(JOB_FORMAT_ERROR);

}
