#include <csse2310a3.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <signal.h>
#include <time.h>

#define UQ_SOLUTION "demo-uqwordiply"
#define MIN_NUM_ARGS 2
#define MAX_NUM_ARGS 4
#define PARALLEL_ARG "--parallel"
#define QUIET_ARG "--quiet"

//MACROS FOR ARRAY INDEXING FOR PROCESSES
#define TEST_PROGRAM 0
#define DEMO_PROGRAM 1
#define UQCMP_STDOUT 2
#define UQCMP_STDERR 3

// MACROS FOR ARRAY INDEXING JOB NUMBERS
#define NUM_JOBS_PASSED 0
#define NUM_JOBS_RUN 1

// PROGRAM SLEEP MACROS
#define JOB_SLEEP_SECONDS 2
#define JOB_SLEEP_NANOSECONDS 0

// Pipes are labelled as per figure 1 in spec sheet
#define NUM_PIPES_JOB 4
#define NUM_PIPE_ENDS 2
#define PIPE_ONE 0
#define PIPE_TWO 1
#define PIPE_THREE 2
#define PIPE_FOUR 3
#define READ_END 0
#define WRITE_END 1

// JOB MACROS
#define NUM_LETTERS_JOB_DESCRIPTION 11
#define NUM_PROCESSES_JOB 4

#define JOB_SUCCESS 1
#define JOB_FAIL 0

#define JOB_DESCRIPTION "Job %d %s"
#define UNABLE_EXECUTE "Job %d: Unable to execute test\n"
#define STDOUT_DIFFERS "Job %d: Stdout differs\n"
#define STDOUT_MATCHES "Job %d: Stdout matches\n"
#define STDERR_DIFFERS "Job %d: Stderr differs\n"
#define STDERR_MATCHES "Job %d: Stderr matches\n"
#define EXIT_MATCHES "Job %d: Exit status matches\n"
#define EXIT_DIFFERS "Job %d: Exit status differs\n"
#define OVERALL_RESULT "testuqwordiply: %d out of %d tests passed\n"
#define START_JOB_MESSAGE "Starting job %d\n"
#define START_JOB_MESSAGE "Starting job %d\n"

// Enum to hold exit statuses
typedef enum {
    OK = 0,
    TESTS_FAILED = 1,
    USAGE_ERROR = 2,
    JOB_FILE_ERROR = 3,
    JOB_FORMAT_ERROR = 4,
    INPUT_FILE_ERROR = 5,
    BLANK_JOB_ERROR = 6,
    EXEC_FAILED = 99
} ExitStatus;

// Structure to hold program information including optional arguments and the
// names of the test program file and job file
typedef struct {
    bool quiet;
    bool parallel;
    char* testProgramName;
    char* jobFileName;
} ProgramParameters;

typedef struct {
    int totalNumJobs;
    char*** jobs;
    char** inputFiles;
} JobDetails;

// Function prototypes
ProgramParameters parse_args(int argc, char** argv);
JobDetails parse_job_file(char* jobFileName);
int* run_test_jobs(ProgramParameters programParams, JobDetails jobDetails);
int* start_job(char* testFileName, char* inputFileName, char** args,
        int jobNum, bool quiet);
int run_test_program(char* testFileName, char* inputFileName, char** args,
        int pipeFDs[NUM_PIPES_JOB][2]);
int run_demo_program(char* inputFileName, char** args,
        int pipeFDs[NUM_PIPES_JOB][2]);
int run_uqcmp(char* checkDest, int jobNum, bool quiet,
        int pipeFDs[NUM_PIPES_JOB][2]);
int report_job(int jobNum, int* processIDs);
void free_statuses(int** jobProcessIDs, int numJobs);
void send_sigkill(int processIDs[NUM_PROCESSES_JOB]);
void quiet_redirect();
void interrupt_test();
void job_sleep();

// Prototypes for helper functions
int count_character(char* word, char letter);
int count_digits(int num);

// Prototypes for error functions
void usage_error();
void job_file_error(char* fileName);
void input_file_error(char* inputFileName, int lineNum, char* fileName);
void job_format_error(int lineNum, char* fileName);
void blank_job_error(char* fileName);

// Global boolean for signal handler
bool testsInterrupted = false;

int main(int argc, char** argv) {
    ProgramParameters programParams;
    JobDetails jobDetails;

    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_handler = interrupt_test;
    sa.sa_flags = SA_RESTART;
    sigaction(SIGINT, &sa, 0);

    programParams = parse_args(argc, argv);
    jobDetails = parse_job_file(programParams.jobFileName);

    int* jobNums = run_test_jobs(programParams, jobDetails);
    printf(OVERALL_RESULT, jobNums[NUM_JOBS_PASSED], jobNums[NUM_JOBS_RUN]);

    if (jobNums[NUM_JOBS_PASSED] == jobNums[NUM_JOBS_RUN]) {
        free(jobNums);
        return OK;
    } else {
        free(jobNums);
        return TESTS_FAILED;
    }
}

ProgramParameters parse_args(int argc, char** argv) {
    ProgramParameters info = { .quiet= false, .parallel = false,
            .testProgramName = NULL, .jobFileName = NULL};
    // Skip over program name argument
    argc--;
    argv++;
    // Check amount of arguments
    if (argc < MIN_NUM_ARGS || argc > MAX_NUM_ARGS) {
        usage_error();
    }
    // Check for optional arguments if they exist
    while (argc > MIN_NUM_ARGS) {
        if (!strcmp(argv[0], QUIET_ARG) && !info.quiet) {
            info.quiet= true;
        } else if (!strcmp(argv[0], PARALLEL_ARG) && !info.parallel) {
            info.parallel = true;
        } else {
            usage_error();
        }
        argc--;
        argv++;
    }
    // Checks if --quiet or --parallel is used after arguments
    if ((argv[0][0] == '-' && argv[0][1] == '-') || 
            (argv[1][0] == '-' && argv[1][1] == '-')) {
        usage_error();
    }
    info.testProgramName = argv[0];
    info.jobFileName = argv[1];

    return info;
}

JobDetails parse_job_file(char* jobFileName) {
    char*** jobs = malloc(0);
    char** inputFiles = malloc(0);
    int totalNumJobs = 0;
    char* line;
    int lineNum = 0;
    int numArgs;
    FILE* file = fopen(jobFileName, "r");
    FILE* inputFile;

    if (!file) {
        job_file_error(jobFileName);
    }
    while ((line = read_line(file))) {
        lineNum++;
        // Checks for comments and blank lines
        if (line[0] == '#' || line[0] == '\0') {
            continue;
        }
        // Check for char before comma, and number of commas
        if (line[0] == ',' || count_character(line, ',') != 1) {
            job_format_error(lineNum, jobFileName);
        }
        char** jobItems = split_line(line, ',');
        inputFile = fopen(jobItems[0], "r");
        if (!inputFile) {
            input_file_error(jobItems[0], lineNum, jobFileName);
        }
        fclose(inputFile);
        char** args = split_space_not_quote(jobItems[1], &numArgs);
        char** job = malloc((numArgs + 2) * sizeof(char*));

        job[0] = NULL; // Later replaced by file name in exec call
        if (numArgs) {
            memcpy(job + 1, args, (numArgs + 1) * sizeof(char*));
        }
        jobs = realloc(jobs, (totalNumJobs + 1) * sizeof(char**));
        inputFiles = realloc(inputFiles, (totalNumJobs + 1) * sizeof(char*));
        inputFiles[totalNumJobs] = strdup(jobItems[0]);
        jobs[totalNumJobs] = job;
        totalNumJobs++;
    }
    fclose(file);
    if (!totalNumJobs) {
        blank_job_error(jobFileName);
    }
    JobDetails jobDetails = {.totalNumJobs = totalNumJobs, .jobs = jobs, 
            .inputFiles = inputFiles};
    return jobDetails;
}

int* run_test_jobs(ProgramParameters programParams, JobDetails jobDetails) {
    int* jobNums = calloc(2, sizeof(int));
    if (programParams.parallel) {
        int** jobProcessIDs = malloc(sizeof(int*) * jobDetails.totalNumJobs);
        for (int i = 0; i < jobDetails.totalNumJobs; i++) {
            printf(START_JOB_MESSAGE, i + 1);
            fflush(stdout);
            //Start each job
            jobProcessIDs[i] = start_job(programParams.testProgramName,
                   jobDetails.inputFiles[i], jobDetails.jobs[i], i + 1,
                   programParams.quiet);
            jobNums[NUM_JOBS_RUN] += 1;
        }
        job_sleep();
        for (int i = 0; i < jobNums[NUM_JOBS_RUN]; i++) {
            send_sigkill(jobProcessIDs[i]);
        }
        for (int i = 0; i < jobNums[NUM_JOBS_RUN]; i++) {
            jobNums[NUM_JOBS_PASSED] += report_job(i + 1, jobProcessIDs[i]);
        }
        free_statuses(jobProcessIDs, jobNums[NUM_JOBS_RUN]);
    } else {
        int* processIDs;
        for (int i = 0; i < jobDetails.totalNumJobs && !testsInterrupted; i++) {
            // Start the job
            printf(START_JOB_MESSAGE, i + 1);
            fflush(stdout);
            processIDs = start_job(programParams.testProgramName,
                    jobDetails.inputFiles[i], jobDetails.jobs[i], i + 1,
                    programParams.quiet);
            jobNums[NUM_JOBS_RUN] += 1;
            job_sleep();
            send_sigkill(processIDs);
            jobNums[NUM_JOBS_PASSED] += report_job(i + 1, processIDs);
            free(processIDs);

        }
    }
    return jobNums;
}

int* start_job(char* testFileName, char* inputFileName, char** args,
        int jobNum, bool quiet) {
    // Used to store 4 process IDs
    int* jobProcessIDs = malloc(sizeof(int) * NUM_PROCESSES_JOB); 

    // Creates fds for pipes numbered 1-4 as per diagram on spec sheet
    int pipeFDs[NUM_PIPES_JOB][2];

    // Creates pipes with file descriptors
    pipe(pipeFDs[PIPE_ONE]);
    pipe(pipeFDs[PIPE_TWO]);
    pipe(pipeFDs[PIPE_THREE]);
    pipe(pipeFDs[PIPE_FOUR]);

    //Create process A (test program)
    jobProcessIDs[TEST_PROGRAM] = run_test_program(testFileName, inputFileName,
            args, pipeFDs);
    
    //Create process B (demo-uqwordiply)
    jobProcessIDs[DEMO_PROGRAM] = run_demo_program(inputFileName, args, pipeFDs);
    
    //Create process C (uqcmp)
    jobProcessIDs[UQCMP_STDOUT] = run_uqcmp("stdout", jobNum,quiet, pipeFDs);

    //Create process D (uqcmp)
    jobProcessIDs[UQCMP_STDERR] = run_uqcmp("stderr", jobNum,quiet, pipeFDs);

    //Close read and write pipe ends in parent as not needed
    for (int i = 0; i < NUM_PIPES_JOB; i++) {
        close(pipeFDs[i][READ_END]);
        close(pipeFDs[i][WRITE_END]);
    }

    return jobProcessIDs;
}

int run_test_program(char* testFileName, char* inputFileName, char** args,
        int pipeFDs[NUM_PIPES_JOB][2]) {
    
    pid_t pID = fork();
    if (!pID) {
        // Child process
        //Close read ends of pipes 1 & 2 as only writing to those pipes
        close(pipeFDs[PIPE_ONE][READ_END]);
        close(pipeFDs[PIPE_TWO][READ_END]);
        // Close read and write ends of pipes 3 & 4 as not needed
        close(pipeFDs[PIPE_THREE][READ_END]);
        close(pipeFDs[PIPE_THREE][WRITE_END]);
        close(pipeFDs[PIPE_FOUR][READ_END]);
        close(pipeFDs[PIPE_FOUR][WRITE_END]);
        // Redirect pipe write ends to stdout and stderr
        dup2(pipeFDs[PIPE_ONE][WRITE_END], STDOUT_FILENO);
        close(pipeFDs[PIPE_ONE][WRITE_END]);
        dup2(pipeFDs[PIPE_TWO][WRITE_END], STDERR_FILENO);
        close(pipeFDs[PIPE_TWO][WRITE_END]);
        //Get stdin from file
        int fdInput = open(inputFileName, O_RDONLY);
        dup2(fdInput, STDIN_FILENO);
        close(fdInput);
        //Run test_program
        args[0] = testFileName;
        execvp(testFileName, args);
        perror("Error: ");
        exit(EXEC_FAILED);
    }
    return pID;
}

int run_demo_program(char* inputFileName, char** args,
        int pipeFDs[NUM_PIPES_JOB][2]) {
        
    pid_t pID = fork();
    if (!pID) {
        // Child process
        //Close read ends of pipes 3 & 4 as only writing to those pipes
        close(pipeFDs[PIPE_THREE][READ_END]);
        close(pipeFDs[PIPE_FOUR][READ_END]);
        // Close read and write ends of pipes 1 & 2 as not needed
        close(pipeFDs[PIPE_ONE][READ_END]);
        close(pipeFDs[PIPE_ONE][WRITE_END]);
        close(pipeFDs[PIPE_TWO][READ_END]);
        close(pipeFDs[PIPE_TWO][WRITE_END]);
        // Redirect pipe write ends to stdout and stderr
        dup2(pipeFDs[PIPE_THREE][WRITE_END], STDOUT_FILENO);
        close(pipeFDs[PIPE_THREE][WRITE_END]);
        dup2(pipeFDs[PIPE_FOUR][WRITE_END], STDERR_FILENO);
        close(pipeFDs[PIPE_FOUR][WRITE_END]);
        //Get stdin from file
        int fdInput = open(inputFileName, O_RDONLY);
        dup2(fdInput, STDIN_FILENO);
        close(fdInput);
        //Run test program
        args[0] = UQ_SOLUTION;
        execvp(UQ_SOLUTION, args); // searching on path - use execvp not execv
        perror("Error: ");
        exit(EXEC_FAILED);
    }
    return pID;
}

int run_uqcmp(char* checkDest, int jobNum, bool quiet,
        int pipeFDs[NUM_PIPES_JOB][2]) {
    pid_t pID = fork();
    if (!pID) {
        //Child process
        //Close write ends of all pipes 
        //Pipe 1 ends aren't closed as they are fds 3 and 4
        close(pipeFDs[PIPE_TWO][WRITE_END]);
        close(pipeFDs[PIPE_THREE][WRITE_END]);
        close(pipeFDs[PIPE_FOUR][WRITE_END]);
        close(STDIN_FILENO);

        if (!strcmp(checkDest, "stdout")) {
            //If process is comparing stdout
            // Close read ends of pipes 2 & 4 as not needed
            close(pipeFDs[PIPE_TWO][READ_END]);
            close(pipeFDs[PIPE_FOUR][READ_END]);
            // Redirect to file descriptors 3 and 4
            dup2(pipeFDs[PIPE_ONE][READ_END], 3);
            dup2(pipeFDs[PIPE_THREE][READ_END], 4);
            close(pipeFDs[PIPE_THREE][READ_END]);
        } else {
            // Close read ends of pipe 3 as not needed
            close(pipeFDs[PIPE_THREE][READ_END]);
            // Redirect to file descriptors 3 and 4
            dup2(pipeFDs[PIPE_TWO][READ_END], 3);
            close(pipeFDs[PIPE_TWO][READ_END]);
            dup2(pipeFDs[PIPE_FOUR][READ_END], 4);
            close(pipeFDs[PIPE_FOUR][READ_END]);
        }
        int jobNumDigits = count_digits(jobNum);
        char jobDesc[NUM_LETTERS_JOB_DESCRIPTION + jobNumDigits];
        sprintf(jobDesc, JOB_DESCRIPTION, jobNum, checkDest);
        char* args[3] = {"uqcmp", jobDesc, NULL};
        if (quiet) {
            quiet_redirect();
        } 
        execvp(args[0], args);
        perror("Error: ");
        exit(EXEC_FAILED);
    }
    return pID;
}

void quiet_redirect() {
    int devNull = open("/dev/null", O_WRONLY);
    dup2(devNull, STDOUT_FILENO);
    dup2(devNull, STDERR_FILENO);
    close(devNull);
}


void job_sleep() {
    struct timespec required, remaining;
    required.tv_sec = JOB_SLEEP_SECONDS;
    required.tv_nsec = JOB_SLEEP_NANOSECONDS;
    while (nanosleep(&required, &remaining) == -1) {
        required = remaining;

    }
}

int report_job(int jobNum, int* processIDs) {
    bool testFailed = false;
    int* statuses = malloc(sizeof(int) * NUM_PROCESSES_JOB);
    for (int i = 0; i < NUM_PROCESSES_JOB; i++) {
        waitpid(processIDs[i], &statuses[i], WCONTINUED);
        if (WIFEXITED(statuses[i])) {
            statuses[i] = WEXITSTATUS(statuses[i]);
        } else {
            statuses[i] = WTERMSIG(statuses[i]);
        }
        if (statuses[i] == EXEC_FAILED) {
            free(statuses);
            printf(UNABLE_EXECUTE, jobNum);
            fflush(stdout);
            return JOB_FAIL;
        }
    }
    if (!statuses[2]) {
        printf(STDOUT_MATCHES, jobNum);
    } else {
        printf(STDOUT_DIFFERS, jobNum);
        testFailed = true;
    }
    fflush(stdout);

    if (!statuses[3]) {
        printf(STDERR_MATCHES, jobNum);
    } else {
        printf(STDERR_DIFFERS, jobNum);
        testFailed = true;
    }
    fflush(stdout);

    if (statuses[0] == statuses[1]) {
        printf(EXIT_MATCHES, jobNum);
    } else {
        printf(EXIT_DIFFERS, jobNum);
        testFailed = true;
    }
    fflush(stdout);
    
    free(statuses);
    if (testFailed) {
        return JOB_FAIL;
    }
    return JOB_SUCCESS;
}

void interrupt_test() {
    testsInterrupted = true;
}

void free_statuses(int** jobProcessIDs, int numJobs) {
    for (int i = 0; i < numJobs; i++) {
        free(jobProcessIDs[i]);
    }
    free(jobProcessIDs);
}

void send_sigkill(int processIDs[NUM_PROCESSES_JOB]) {
    for (int i = 0; i < NUM_PROCESSES_JOB; i++) {
        kill(processIDs[i], SIGKILL);
    }

}

int count_digits(int num) {
    int numCopy = num;
    int numDigits = 0;
    while (numCopy != 0) {
        numCopy /= 10;
        numDigits++;
    }
    return numDigits;
}

int count_character(char* word, char letter) {
    int numOccurrences = 0;
    for (int i = 0; word[i] != '\0'; i++) {
        if (word[i] == letter) {
            numOccurrences++;
        }
    }
    return numOccurrences;
}

void usage_error() {
    fprintf(stderr, "Usage: testuqwordiply [--quiet] [--parallel] testprogram "
            "jobfile\n");
    exit(USAGE_ERROR);
}

void job_file_error(char* fileName) {
    fprintf(stderr, "testuqwordiply: Unable to open job file \"%s\"\n", 
            fileName);
    exit(JOB_FILE_ERROR);
}

void job_format_error(int lineNum, char* fileName) {
    fprintf(stderr, "testuqwordiply: syntax error on line %d of \"%s\"\n", 
            lineNum, fileName);
    exit(JOB_FORMAT_ERROR);

}

void input_file_error(char* inputFileName, int lineNum, char* fileName) {
    fprintf(stderr, "testuqwordiply: unable to open file \"%s\" specified on "
            "line %d of \"%s\"\n", inputFileName, lineNum, fileName);
    exit(INPUT_FILE_ERROR);
}

void blank_job_error(char* fileName) {
    fprintf(stderr, "testuqwordiply: no jobs found in \"%s\"\n", fileName);
    exit(BLANK_JOB_ERROR);
}
